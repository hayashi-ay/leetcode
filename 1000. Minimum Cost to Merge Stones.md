バックトラッキングで試していくのが1番最初に思いついて実装も簡単そう。選択肢の数は初回が（n-k+1)、次は(n-2(k - 1)+1)となるので、
組み合わせの数としては、(n - k + 1) * (n - 2(k - 1) + 1) * (n - 3(k - 1) + 1) ... * 1となる。
特にk = 2の場合を考えると、(n - 1)!になるので、n = 30という課題の制約下ではTLEになりそう。

k == 2のとき。二分木の頂点のコストが最小になるようにすれば良い。頂点は`[ 0, len(stones) )`の範囲を表しているので、部分問題として部分木が最小になるようにすれば良い。
minimum_cost[i:j)の部分問題として、`min( [ minimum_cost[i:m) + minimum_cost[m:j) for m in range(i,j) ] )`を解けば良い。

2分木
```
    (1234)
   /     \
 (123)    4
 /   \
(12)  3
/  \
1   2

    (1234)
   /     \
  1    (234)
      /    \
    (23)    4
    /  \
   2    3
```

k = 2のときの場合のコード
```python
class Solution:
    def mergeStones(self, stones: List[int], k: int) -> int:

        @cache
        def merge(left, right):
            num_stones = right - left
            if num_stones == 1:
                return 0
            if num_stones == 2:
                return stones[left] + stones[right - 1]
            costs = inf
            for i in range(left + 1, right):
                costs = min(costs, merge(left, i) + merge(i, right))
            costs += sum(stones[left:right])
            return costs 

        return merge(0, len(stones))
```

3分木
```
　　　(1234567)
     /   |    \
   (123)(456)(7)
   /|\  /|\   |
  1 2 3 4 5 6 7

      (1234567)
     /   |    \
   (1) (234)(567)
    |   /|\  /|\
    1  2 3 4 5 6 7
```

k = 3のときのコード
```python
class Solution:
    def mergeStones(self, stones: List[int], k: int) -> int:

        @cache
        def merge(left, right):
            num_stones = right - left
            if num_stones == 1:
                return 0
            if num_stones < 3:
                return inf
            if num_stones == 3:
                return sum(stones[left:right])
            costs = inf
            for i in range(left + 1, right - 1):
                for j in range(i + 1, right):
                    costs = min(costs, merge(left, i) + merge(i, j) + merge(j, right))
            costs += sum(stones[left:right])
            return costs 

        ans = merge(0, len(stones))
        if ans == inf:
            return -1
        return ans
```

あとは上記を一般化すれば良い。


1st

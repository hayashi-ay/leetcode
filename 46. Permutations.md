backtrackingで全通りを試すか、現在のpermutationを元に次のpermutationを求める方法で実装する。

1st

backtracking
時間計算量：O(n!)
空間計算量：O(n!) ← 関数呼び出しのスタックの最大値はnだがpermutationの数がn!個ある。

```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        def traverse(permutation, candidates):
            if len(permutation) == len(nums):
                permutations.append(permutation.copy())
            for i, num in enumerate(candidates):
                permutation.append(num)
                next_candidates = candidates[:i] + candidates[i + 1:]
                traverse(permutation, next_candidates)
                permutation.pop()

        permutations = []
        traverse([], nums)
        return permutations
```


2nd


3rd

inorderにちゃんと昇順になっているかを見ていくか上限と下限を意識してノードを見ていくか。

1st

DFS stack inorder
昇順になっているか。
```python
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        if root is None:
            return True
        nodes = []
        current = root
        prev_value = -inf
        # 左がある場合はひたすらスタックに積む。なくなったらポップして、右のノードに移り同様のことを繰り返す
        while nodes or current:
            while current:
                nodes.append(current)
                current = current.left
            node = nodes.pop()
            if prev_value >= node.val:
                return False
            prev_value = node.val
            current = node.right
        return True
```

> stack or node があんまり気に入らないのですよね。
(まだ言っている。)

> 基本的に、名前の付け方は色々だと思います。
nodes は、どういう物が入っているか、
stack は、どういう動作をする変数か、
このあたりも、前後から詳細が簡単に分かればそれでいいのですが、なかなかこのコードだと難しいです。
どういう扱いが必要なものかまで分かると一番読みやすいように思います。

> これ、下のように変形すると、nodes に対して結構素直にスタックを用いた再帰をしているんです。
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        prev_value = -inf
        nodes = []
        current = root
        while current:
            nodes.append(current)
            current = current.left
        while nodes:
            node = nodes.pop()
            if prev_value >= node.val:
                return False
            prev_value = node.val
            current = node.right
            while current:
                nodes.append(current)
                current = current.left
        return True


DFS recursion
上限と下限のルールを満たしているか。
```python
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        def is_valid(node, lower, upper):
            if node is None:
                return True
            if not (lower < node.val < upper):
                return False
            return is_valid(node.left, lower, node.val) and is_valid(node.right, node.val, upper)
        return is_valid(root, -inf, inf)
```

2nd

上限と下限のルールを満たしているか、recursion
```python
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        if root is None:
            return True
        nodes = [(root, -inf, inf)] # (node, lower_limit, upper_limit)
        while nodes:
            node, lower, upper = nodes.pop()
            if node is None:
                continue
            if not (lower < node.val < upper):
                return False
            nodes.append((node.left, lower, node.val))
            nodes.append((node.right, node.val, upper))
        return True
```

3rd

```python
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        if root is None:
            return True
        nodes = [(root, -inf, inf)]
        while nodes:
            node, lower, upper = nodes.pop()
            if node is None:
                continue
            if not (lower < node.val < upper):
                return False
            nodes.append((node.left, lower, node.val))
            nodes.append((node.right, node.val, upper))
        return True
```

4th
1stの書き直し。

```python
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        prev_value = -inf
        nodes = []
        current = root
        while True:
            while current:
                nodes.append(current)
                current = current.left
            if not nodes:
                break
            node = nodes.pop()
            if prev_value >= node.val:
                return False
            prev_value = node.val
            current = node.right
        return True
```

基本的にはLinked List Cycleと同じ。フロイドのアルゴリズムでやる場合は少し工夫が必要だが、setを使う場合はほとんど同じ。

1st

```python
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        seen = set()
        current_node = head
        while current_node:
            seen.add(current_node)
            current_node = current_node.next
            if current_node in seen:
                return current_node
        return None
```

> ループの途中で回しているものが変わらない方が分かりやすい。上の例だとL11とL13で`current_node`が指しているものが変わっている。

うさぎとかめ。遭遇した点からheadにslowを戻して今度は1歩ずつ進めば再度遭遇する点がサイクルの始まり。

```python
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head:
            return None
        slow = head
        fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                break
        if not (fast and fast.next):
            return None
        slow = head
        while slow != fast:
            slow = slow.next
            fast = fast.next
        return slow
```

```
        if not head:
            return None
```
の部分がなくても結果が変わらない。

2nd

`if current_node in seen:`を先頭にしてみた。好みの問題、流れとしては1stの方が自然かも。

```python
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        seen = set()
        current_node = head
        while current_node:
            if current_node in seen:
                return current_node
            seen.add(current_node)
            current_node = current_node.next
        return None
```

関数に切り出してみた。コードの意図は分かりやすくなったが、有名なアルゴリズムなので1stにコメントで補足するだけで十分かなと思った。

```python
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        def find_first_meet_node(start):
            if not start:
                return None
            slow = start
            fast = start
            while fast and fast.next:
                slow = slow.next
                fast = fast.next.next
                if slow == fast:
                    return slow
            return None
        first_meet_node = find_first_meet_node(head)
        if not first_meet_node:
            return None
        from_start = head
        from_first_meet = first_meet_node
        while from_start != from_first_meet:
            from_start = from_start.next
            from_first_meet = from_first_meet.next
        return from_start
```

```
            if not start:
                return None
```
の部分がなくても結果が変わらない。

3rd

色々試しましたが、結局１番最初のコードが良いかなと思いました。

```python
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        seen = set()
        current_node = head
        while current_node:
            seen.add(current_node)
            current_node = current_node.next
            if current_node in seen:
                return current_node
        return None
```

## 概要
> Given an integer array `nums` and an integer `k`, return _the_ `k` _most frequent elements_. You may return the answer in **any order**.

## 方針

### Sort
Time Complexity: $O(n\log n)$
Space Complexity: $O(n)$
Where: `n = len(nums)`

```python
def topKFrequent(self, nums: List[int], k: int) -> List[int]:
	counter = Counter(nums)
	unique = list(counter.keys())
	unique.sort(key=lambda x: counter[x], reverse=True)
	return unique[:k]
```

### MinHeap
Time Complexity: $O(n\log k)$
Space Complexity: $O(k)$
Where: `n = len(nums)`

```python
def topKFrequent(self, nums: List[int], k: int) -> List[int]:
	counter = Counter(nums)
	unique = list(counter.keys())
	# min heap
	heap = [] # (freq, num)
	for num in unique:
		heapq.heappush(heap, (counter[num], num))
		if len(heap) > k:
			heapq.heappop(heap)
	ans = []
	for freq, num in heap:
		ans.append(num)
	return ans
```
### Quickselect
Time Complexity: $O(n)$ in average, $O(n^2)$ in the worst case
Space Complexity: $O(n)$
Where: `n = len(nums)`

```python
def topKFrequent(self, nums: List[int], k: int) -> List[int]:

	def partition(arr, left, right, pivot_index):
		pivot_value = counter[arr[pivot_index]]
		# move pivot to the right
		arr[pivot_index], arr[right] = arr[right], arr[pivot_index]
		sorted_index = left
		for idx in range(left, right):
			if counter[arr[idx]] >= pivot_value:
				arr[idx], arr[sorted_index] = arr[sorted_index], arr[idx]
				sorted_index += 1
		# move pivot back
		arr[sorted_index], arr[right] = arr[right], arr[sorted_index]
		return sorted_index
	
	def quick_select(arr, left, right, kth_index):
		if left == right:
			return
		pivot_index = random.randint(left, right)
		pivot_index = partition(arr, left, right, pivot_index)
		if pivot_index == kth_index:
			return
		elif pivot_index > kth_index:
			quick_select(arr, left, pivot_index - 1, kth_index)
		else:
			quick_select(arr, pivot_index + 1, right, kth_index)

	counter = Counter(nums)
	unique = list(counter.keys())
	quick_select(unique, 0, len(unique) - 1, k - 1)
	return unique[:k]
```


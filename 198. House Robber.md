隣合う家で盗みを働くことはできないという制約がある。
i番目の家まで強盗する際の最大値金額は、（i-2番目までの最大値 + i番目）＝ i番目に盗みに入る or (i-1番目の最大値）= i番目に盗みに入らないになる。

1st

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) <= 2:
            return max(nums)

        max_money = [0] * len(nums)
        max_money[0] = nums[0]
        max_money[1] = max(nums[0], nums[1])
        for i in range(2, len(nums)):
            max_money[i] = max(max_money[i - 2] + nums[i], max_money[i - 1])
        return max_money[len(nums) - 1]
```

> これ、len(nums) == 1は特別扱いの必要ありますけれども、2は下に合流させてもいいんじゃないですか。まあ、どちらをどうするかは趣味の範囲だと思いますが。

2nd

1stの命名を変えたくらい。
```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) <= 2:
            return max(nums)

        max_amount = [0] * len(nums)
        max_amount[0] = nums[0]
        max_amount[1] = max(nums[0], nums[1])
        for i in range(2, len(nums)):
            max_amount[i] = max(max_amount[i - 2] + nums[i], max_amount[i - 1])
        return max_amount[len(nums) - 1]
```

空間計算量をO(1)にした版。
```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) <= 2:
            return max(nums)
        
        max_amount_two_before = nums[0]
        max_amount_one_before = max(nums[0], nums[1])
        for i in range(2, len(nums)):
            current_max = max(max_amount_two_before + nums[i], max_amount_one_before)
            max_amount_two_before = max_amount_one_before
            max_amount_one_before = current_max
        return max_amount_one_before
```

3rd
1st, 2ndがすんなりと書けたので書き直しは1度のみ。
```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) <= 2:
            return max(nums)
        
        max_amount = [0] * len(nums)
        max_amount[0] = nums[0]
        max_amount[1] = max(nums[0], nums[1])
        for i in range(2, len(nums)):
            max_amount[i] = max(max_amount[i - 2] + nums[i], max_amount[i - 1])
        return max_amount[len(nums) - 1]
```

とりあえず実験。
```
0
01
0110
01101001
0110100110010110
```

- 毎操作ごとに配列の長さは倍になる。
- 配列の前半は１つ前と同じ値になる

愚直に配列を作っていけば簡単だが、1 <= n <= 30なので、2^29の長さになる。
2^32がUINT_MAXで40億(4 billion)ほどで2^29は8で割って5億ほど。
charの配列だとすると1バイト×0.5 billion(10^9) = 0.5GBになる。意外と許容範囲かも。
8ビットまとめて表すと60MBほど（Cなどのintでの考えなのでPythonだと異なるので参考程度）

頑張れば周期性なども見えて気もするが思いつかず。

1st
Memory Limit Exceed。結構愚直な方法。

```python
class Solution:
    def kthGrammar(self, n: int, k: int) -> int:
        symbols = [0, 1]
        for i in range(3, n + 1):
            start = 1 << (i - 3)
            stop = start << 1
            while start < stop:
                if symbols[start] == 0:
                    symbols.extend([0, 1])
                else:
                    symbols.extend([1, 0])
                start += 1
        return symbols[k - 1]
```

回答を見て再帰で解いた。Binary Treeとして考えれる。
(n, k)の親の位置は(n - 1, (k+1) // 2)になる。1-indexedなのに注意。
親が分かれば親と自分の偶奇によって自分のノードの値が定まる。

```python
class Solution:
    def kthGrammar(self, n: int, k: int) -> int:
        if n == 1:
            return 0
        parent = self.kthGrammar(n - 1, (k + 1) // 2)
        if parent == 0:
            if k % 2:
                return 0
            else:
                return 1
        else:
            if k % 2:
                return 1
            else:
                return 0
```

2nd

if文を削ってみた。

```python
class Solution:
    def __init__(self):
        self.rules = {0: [0, 1], 1: [1, 0]}

    def kthGrammar(self, n: int, k: int) -> int:
        if n == 1:
            return 0
        parent = self.kthGrammar(n - 1, (k + 1) // 2)
        return self.rules[parent][(k - 1) % 2]
```


3rd

```python
class Solution:
    def kthGrammar(self, n: int, k: int) -> int:
        if n == 1:
            return 0
        parent = self.kthGrammar(n - 1, (k + 1) // 2)
        if parent == 0:
            if k % 2 == 1:
                return 0
            else:
                return 1
        else:
            if k % 2 == 1:
                return 1
            else:
                return 0
```

4th

```python
class Solution:
    def kthGrammar(self, n: int, k: int) -> int:
        if n == 1:
            return 0
        previous_value = self.kthGrammar(n - 1, (k + 1) // 2)
        if previous_value == 0:
            if k % 2:
                return 0
            else:
                return 1
        else:
            if k % 2:
                return 1
            else:
                return 0
```

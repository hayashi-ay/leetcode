`[4, 5, 6, 7, 0, 1, 2]`という配列を考える。1番右端と自分を比較して自分の方が大きければ、自分より右側に最小値がある。自分の方が小さいまたは等しい（右端同士を比較）場合は自分か自分より左に最小値がある。

1st

`nums[-1]`はright_endなどと変数にしても良いかもしれない。ただやり過ぎか。

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        left, right = 0, len(nums) - 1
        while left < right:
            mid = (left + right) // 2
            if nums[mid] > nums[-1]:
                left = mid + 1
            else:
                right = mid
        return nums[left]
```

2nd

左端と比較するパターン。この場合はあらかじめ左端が最小かどうかを確認する必要がある。
その上で、1番左と比較して自分の方が大きければ自分より右にある（自分が左端も考慮すると>=にする必要がある）、自分の方が小さければ自分か左にある。
1stの方がシンプル。

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        if len(nums) == 1 or nums[0] < nums[-1]:
            return nums[0]
        left, right = 0, len(nums) - 1
        while left < right:
            mid = (left + right) // 2
            if nums[mid] >= nums[0]:
                left = mid + 1
            else:
                right = mid
        return nums[left]
```


3rd
```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        left, right = 0, len(nums) - 1
        while left < right:
            mid = (left + right) // 2
            if nums[mid] > nums[-1]:
                left = mid + 1
            else:
                right = mid
        return nums[left]
```

4th
閉区間
```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        low = 0
        high = len(nums) - 1
        while low < high:
            middle = (low + high) // 2
            if nums[middle] > nums[-1]:
                low = middle + 1
            else:
                high = middle
        return nums[low]
```

半開区間
```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        low = 0
        high = len(nums)
        while low < high:
            middle = (low + high) // 2
            if nums[middle] > nums[-1]:
                low = middle + 1
            else:
                high = middle
        return nums[low]
```

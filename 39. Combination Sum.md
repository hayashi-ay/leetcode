1st

```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        
        combinations = []
        partial_combination = []
        candidates.sort(reverse=True)

        def find_combinations_totaled_to_target(index, total):
            if total == target:
                combinations.append(partial_combination.copy())
                return
            if index >= len(candidates):
                return
            find_combinations_totaled_to_target(index + 1, total)
            num = candidates[index]
            count = 0
            while total + num * (count + 1) <= target:
                partial_combination.append(num)
                find_combinations_totaled_to_target(index + 1, total + num * (count + 1))
                count += 1
            while count > 0:
                partial_combination.pop()
                count -= 1

        find_combinations_totaled_to_target(0, 0)
        return combinations
```

> import sys
sys.getrecursionlimit()
sys.setrecursionlimit(2000)
再帰深くなるとこういうのがあるというのは知っておいてもいいかもしれません。

2nd

1stを書き換え。
```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        all_combinations = []
        partial_combination = []

        def make_combinations_totaled_to_target(candidate_index, total):
            if total == target:
                all_combinations.append(partial_combination.copy())
                return
            if candidate_index >= len(candidates):
                return
            make_combinations_totaled_to_target(candidate_index + 1, total)
            num = candidates[candidate_index]
            original_size = len(partial_combination)
            for i in range((target - total) // num):
                partial_combination.append(num)
                make_combinations_totaled_to_target(candidate_index + 1, total + num * (i + 1))
            while len(partial_combination) > original_size:
                partial_combination.pop()
        
        make_combinations_totaled_to_target(0, 0)
        return all_combinations
```

1つの再帰の中で追加する要素を1つまでにした版。
```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        all_combinations = []
        partial_combination = []

        def find_combinations_summed_up_to_target(index, total):
            if total == target:
                all_combinations.append(partial_combination.copy())
                return
            if total > target:
                return
            if index >= len(candidates):
                return
            find_combinations_summed_up_to_target(index + 1, total)
            partial_combination.append(candidates[index])
            find_combinations_summed_up_to_target(index, total + candidates[index])
            partial_combination.pop()

        find_combinations_summed_up_to_target(0, 0)
        return all_combinations
```


3rd

```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        all_combinations = []
        partial_combination = []

        def make_combinations_summed_up_to_target(candidate_index, current_sum):
            if current_sum == target:
                all_combinations.append(partial_combination.copy())
                return
            if current_sum > target:
                return
            if candidate_index >= len(candidates):
                return
            make_combinations_summed_up_to_target(candidate_index + 1, current_sum)
            candidate = candidates[candidate_index]
            partial_combination.append(candidate)
            make_combinations_summed_up_to_target(candidate_index, current_sum + candidate)
            partial_combination.pop()
        
        make_combinations_summed_up_to_target(0, 0)
        return all_combinations
```

4th

命名などが違うだけで3rdとほぼ同じ。

```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        all_combinations = []
        partial_combination = []

        def make_combination(index, current_sum):
            if current_sum > target:
                return
            if current_sum == target:
                all_combinations.append(partial_combination.copy())
                return
            if index >= len(candidates):
                return
            make_combination(index + 1, current_sum)
            partial_combination.append(candidates[index])
            make_combination(index, current_sum + candidates[index])
            partial_combination.pop()
        
        make_combination(0, 0)
        return all_combinations
```

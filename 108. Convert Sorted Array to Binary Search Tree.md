愚直に前からBSTを構築していって偏りがでたら回転してバランスさせるのでも良いが、今回は下のlistがソート済みという利点を活かしたい。
真ん中の要素がrootノードになる。要素数が偶数の場合はどちらを真ん中にしても良い。同じ要領で今度は左側と右側についてrootノードを決めてあげれば良い。
再帰で書くと良い。

1st

Time Complexity: $O(n)$
Space Complexity: $O(logn)$ ← balancedなので。
Where: `n = len(nums)`

```python
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        if not nums:
            return None
        mid = len(nums) // 2
        node = TreeNode(nums[mid])
        node.left = self.sortedArrayToBST(nums[:mid])
        node.right = self.sortedArrayToBST(nums[mid + 1:])
        return node
```

ヘルパー関数を使う番。
```python
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        def make_bst_from_sorted_array(sorted_nums, left, right):
            if not (left <= right):
                return None
            mid = (left + right) // 2
            node = TreeNode(sorted_nums[mid])
            node.left = make_bst_from_sorted_array(sorted_nums, left, mid - 1)
            node.right = make_bst_from_sorted_array(sorted_nums, mid + 1, right)
            return node

        return make_bst_from_sorted_array(nums, 0, len(nums) - 1)
```

2nd

右端を開区間にした版。

```python
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        def make_bst(sorted_nums, left, right):
            if not (left < right):
                return None
            mid = (left + right) // 2
            node = TreeNode(sorted_nums[mid])
            node.left = make_bst(sorted_nums, left, mid)
            node.right = make_bst(sorted_nums, mid + 1, right)
            return node
        return make_bst(nums, 0, len(nums))
```

ループでも解いてみた。dequeを使っても良い。二分木はリストと違ってSentinelノードを使えない。再帰の方が楽。
```python
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        if not nums:
            return None
        mid = len(nums) // 2
        root = TreeNode(nums[mid])
        nodes = [] # (parent_node, left, right)
        nodes.append((root, 0, mid - 1))
        nodes.append((root, mid + 1, len(nums) - 1))
        while nodes:
            next_nodes = []
            for parent, left, right in nodes:
                if not (left <= right):
                    continue
                mid = (left + right) // 2
                child = TreeNode(nums[mid])
                if child.val < parent.val:
                    parent.left = child
                else:
                    parent.right = child
                next_nodes.append((child, left, mid - 1))
                next_nodes.append((child, mid + 1, right))
            nodes = next_nodes
        return root
```

> いいと思います。
あえていうと、child.val と parent.val を比較してどっちに書き込むかがあんまりいけていない感じがします。
C++ だと、メンバへのポインターというものがあるんですが、
Python だと、__setattr__ ですかねえ。
parent.__setattr__('left', None)
ちょっと魔術感があって気に食わないのですが。

3rd

1stの解法と同じ。

```python
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        if not nums:
            return None
        mid = len(nums) // 2
        node = TreeNode(nums[mid])
        node.left = self.sortedArrayToBST(nums[:mid])
        node.right = self.sortedArrayToBST(nums[mid + 1:])
        return node
```

4th

```python
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        if nums == []:
            return None
        middle_index = len(nums) // 2
        node = TreeNode(nums[middle_index])
        node.left = self.sortedArrayToBST(nums[:middle_index])
        node.right = self.sortedArrayToBST(nums[middle_index + 1:])
        return node
```

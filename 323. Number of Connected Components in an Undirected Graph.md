グラフの問題。「200. Number of Islands」とだいたい同じ。
DFS/BFS/Union Findあたりの解法がある。

1st

DFS  
Time Complexity:  $O(n + e)$ ← 隣接リストを作るのにe, DFSがn回ループで回るが、seenで管理しているので各ノードには1回のみ訪れる、辺についても各ノードに訪れた際に呼ばれるだけ。  
Space Complexity: $O(n + e)$ ← seenの最大サイズはノードの数、また再帰のスタックの最大もノードの数になる。隣接リストは辺の数。  
Where: `e = len(edges)`  

```python
class Solution:
    def countComponents(self, n: int, edges: List[List[int]]) -> int:
        adj = defaultdict(list)
        for node1, node2 in edges:
            adj[node1].append(node2)
            adj[node2].append(node1)
        seen = set()

        def visit_connected_node(node):
            if node in seen:
                return
            seen.add(node)
            for next_node in adj[node]:
                visit_connected_node(next_node)

        count = 0
        for node_idx in range(n):
            if node_idx not in seen:
                count += 1
                visit_connected_node(node_idx)
        return count
```

2nd

DFS。1stとそんなに変わらない。
```python
class Solution:
    def countComponents(self, n: int, edges: List[List[int]]) -> int:
        adj = defaultdict(list)
        for node1, node2 in edges:
            adj[node1].append(node2)
            adj[node2].append(node1)
        seen = set()

        def visit_connected_nodes(node):
            if node in seen:
                return
            seen.add(node)
            for next_node in adj[node]:
                visit_connected_nodes(next_node)

        num_of_connected_components = 0
        for node_idx in range(n):
            if node_idx not in seen:
                num_of_connected_components += 1
                visit_connected_nodes(node_idx)
        return num_of_connected_components
```

UnionFind 経路圧縮のみ。  
Time Complexity:  $O(n + e\ log\ n)$ ← UFの初期化でO(n), すべてのエッジについてunionが呼ばれるのでO(e * logn)  
Space Complexity: $O(n)$ ← UnionFindの分。  
Where: `e = len(edges)`  

```python
class UnionFind:
    def __init__(self, size):
        self.groups = [i for i in range(size)]
    
    def find(self, node):
        if self.groups[node] == node:
            return node
        self.groups[node] = self.find(self.groups[node])
        return self.groups[node]
    
    def union(self, node1, node2):
        group1 = self.find(node1)
        group2 = self.find(node2)
        if group1 == group2:
            return 0
        self.groups[group2] = group1
        return 1

class Solution:
    def countComponents(self, n: int, edges: List[List[int]]) -> int:
        uf = UnionFind(n)
        connected = 0
        for node1, node2 in edges:
            connected += uf.union(node1, node2)
        return n - connected
```

3rd

```python
```

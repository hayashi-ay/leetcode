nums[i]とnums[-1]を比較してnums[i]の方が大きい場合は左側は昇順に並んでいる。それ以外の場合は右側が昇順に並んでいる。
targetが昇順に並んでいる側の範囲にあればそちらを見に行く。そうでなければ反対側を見に行く。

1st
```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return mid
            if nums[mid] > nums[-1]:
                # 左側が昇順に並んでいる
                if nums[left] <= target <= nums[mid]:
                    right = mid - 1
                else:
                    left = mid + 1
            else:
                # 右側が昇順に並んでいる
                if nums[mid] <= target <= nums[right]:
                    left = mid + 1
                else:
                    right = mid - 1
        return -1
```

2nd

pivot_indexを見つける。その後Binary Search。1stと違い2回Binary Searchをすることになる。
```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        def find_pivot_index(left, right):
            while left < right:
                mid = (left + right) // 2
                if nums[mid] > nums[-1]:
                    left = mid + 1
                else:
                    right = mid
            return left
        
        def binary_search(left, right, target):
            while left <= right:
                mid = (left + right) // 2
                if nums[mid] == target:
                    return mid
                elif nums[mid] < target:
                    left = mid + 1
                else:
                    right = mid - 1
            return -1

        pivot_index = find_pivot_index(0, len(nums) - 1)
        if nums[pivot_index] <= target <= nums[-1]:
            left = pivot_index
            right = len(nums) - 1
        else:
            left = 0
            right = pivot_index - 1
        return binary_search(left, right, target)
```

2nd-1の解法のbinary search部分をbisectモジュールを使うように。
```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        def find_pivot_index(left, right):
            while left < right:
                mid = (left + right) // 2
                if nums[mid] > nums[-1]:
                    left = mid + 1
                else:
                    right = mid
            return left

        pivot_index = find_pivot_index(0, len(nums) - 1)
        if nums[pivot_index] <= target <= nums[-1]:
            left = pivot_index
            right = len(nums)
        else:
            left = 0
            right = pivot_index

        index = bisect.bisect_left(nums, target, left, right)
        if index < len(nums) and nums[index] == target:
            return index
        return -1
```

3rd

1stと同じ。
```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return mid
            
            if nums[mid] > nums[-1]:
                # 左側が昇順に並んでいる
                if nums[left] <= target <= nums[mid]:
                    right = mid - 1
                else:
                    left = mid + 1
            else:
                # 右側が昇順に並んでいる
                if nums[mid] <= target <= nums[right]:
                    left = mid + 1
                else:
                    right = mid - 1
        return -1
```

4th

閉区間
```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums) - 1

        while left <= right:
            middle = (left + right) // 2
            if nums[middle] == target:
                return middle
            if nums[middle] > nums[-1]:
                if nums[left] <= target < nums[middle]:
                    right = middle - 1
                else:
                    left = middle + 1
            else:
                if nums[middle] < target <= nums[right]:
                    left = middle + 1
                else:
                    right = middle - 1
        return -1
```

半開区間
```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums)

        while left < right:
            middle = (left + right) // 2
            if nums[middle] == target:
                return middle
            if nums[middle] > nums[-1]:
                # middleを含む左側は昇順
                if nums[left] <= target < nums[middle]:
                    right = middle
                else:
                    left = middle + 1
            else:
                # middleを含む右側は昇順
                if nums[middle] < target <= nums[right - 1]:
                    left = middle + 1
                else:
                    right = middle
        return -1
```

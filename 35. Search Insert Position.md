二分探索。

1st

target以上の値になる位置を求める。それがinsert position。
pythonではオーバーフローを考慮しなくて良いが、考慮する必要がある言語だと mid = left + (right - left) // 2のようにする。
```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums)
        while left < right:
            mid = (left + right) // 2
            if nums[mid] >= target:
                right = mid
            else:
                left = mid + 1
        return left
```

> コードはいいと思います。
これ、どう考えるといいかなあと思っています。
n 個要素があると、植木算で n + 1 個の切れ目がありますね。
そのうち、どこで切ると、
右はすべて、target <= nums[i] で、
左はすべて、nums[i] < target となるか、ということですね。
これを answer とでもしましょう。
だから、left と right は実は閉区間で、一致するまで回さないといけませんね。
mid = (left + right) // 2
とすると、切り捨てられるので、
left <= mid < right
になります。
nums[mid] < target
が判明すると、
mid < answer が分かります。
一方、
target <= nums[mid]
が判明すると、
answer <= mid
が分かりますね。

2nd
bisectモジュール。
bisect_leftの実装はここ。https://github.com/python/cpython/blob/cfbdce72083fca791947cbb18114115c90738d99/Lib/bisect.py#L74
Pythonで実装されていて特に変なことはしてない。
```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        return bisect.bisect_left(nums, target)
```

`[:i]`についてtargetより小さく、`[i:]`についてtarget以上になるiを求める。
```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        low, high = 0, len(nums)
        while low < high:
            mid = (low + high) // 2
            if nums[mid] < target:
                low = mid + 1
            else:
                high = mid
        return low
```

3rd

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums)
        while left < right:
            mid = (left + right) // 2
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid
        return left
```


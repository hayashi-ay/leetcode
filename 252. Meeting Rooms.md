1st

```python
class Solution:
    def canAttendMeetings(self, intervals: List[List[int]]) -> bool:
        intervals.sort()
        previous_meeting_end = -1
        for start, end in intervals:
            if start < previous_meeting_end:
                return False
            previous_meeting_end = end
        return True
```

2nd

heapを使った解法。この問題ではソートに対して優位性はない、計算量的には同じだが、ソートの方はCで書かれたコードが動く分早い気がする。
ただ、途中でintervalsが追加されるなどがあればソートし直す必要がなくて、O(logn)で追加するだけで済むheapの方に分がありそう。

https://docs.python.org/3/library/heapq.html#theory
> So, a heap is a good structure for implementing schedulers (this is what I used for my MIDI sequencer :-).

```python
class Solution:
    def canAttendMeetings(self, intervals: List[List[int]]) -> bool:
        heapq.heapify(intervals)
        previous_meeting_end = -1
        while intervals:
            start, end = heapq.heappop(intervals)
            if start < previous_meeting_end:
                return False
            previous_meeting_end = end
        return True
```

3rd

1stと同じ。
```python
class Solution:
    def canAttendMeetings(self, intervals: List[List[int]]) -> bool:
        intervals.sort()
        previous_meeting_end = -1
        for start, end in intervals:
            if start < previous_meeting_end:
                return False
            previous_meeting_end = end
        return True
```

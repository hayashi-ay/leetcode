可能なsubsetを全て返す必要がある。空集合も含める必要がある。
backtrackingで全通りを試すと良い。~各要素についてsubsetに含める、含めないの2択があるのでTime ComplexityはO(2^n)になる。~
各要素についてsubsetに含めるか含めないかの2択があり状態数が2^n個あり、backtrack関数内でsubsetのcopyが走るので時間計算量としてはO(n・2^n）になる。

1st
```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        subsets = []
        subset = []

        def backtrack(index):
            if index == len(nums):
                subsets.append(subset.copy())
                return
            subset.append(nums[index])
            backtrack(index + 1)
            subset.pop()
            backtrack(index + 1)

        backtrack(0)
        return subsets
```

> backtrack にしろ traverse にしろ、dfs と同じで、どう動くかを説明していて、何が返ってくるかを説明していないです。
読む方の都合からすると、どういう方法で届けられたかよりは、何が戻ってくるのかを知りたいんですが、これくらい短いコードだと、あまりうるさいことをいう気はないのですが。

2nd
backtrackを再帰の代わりにstackを使う版。
```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:      
        subsets = []

        building_subset_stack = [([], 0)] # (subset, index)
        while building_subset_stack:
            subset, index = building_subset_stack.pop()
            if index == len(nums):
                subsets.append(subset)
                continue
            building_subset_stack.append((subset + [nums[index]], index + 1))
            building_subset_stack.append((subset.copy(), index + 1))
        return subsets
```

LeetCodeの解法を見た。既存のsubsetsに含まれる全てのsubsetに現在注目している値を追加したsubsetを加える。
```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        subsets = [[]]
        for num in nums:
            subsets.extend([subset + [num] for subset in subsets])
        return subsets
```

ビット列として考えたときに1が立っている位置のnumsを追加していくことで1つずつsubsetを生成していく。
bitmaskの右端がnumsの左端に対応。←直感的ではないかもしれないが処理がこっちの方が楽。
```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        def make_subset_from_bitmask(bitmask):
            subset = []
            index = 0
            while bitmask:
                if bitmask & 1:
                    subset.append(nums[index])
                bitmask >>= 1
                index += 1
            return subset

        subsets = []
        bitmask = 0
        for bitmask in range(2 ** len(nums)):
            subsets.append(make_subset_from_bitmask(bitmask))
        return subsets
```

ビット列を使う版の亜種。formatを使う代わりに`bin()`を使っても良い。この場合は`0b`を取り除かないといけない。
```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        subsets = []
        binary_format_with_width = f"{len(nums)}b"
        for bit in range(2 ** len(nums)):
            bitmask = format(bit, binary_format_with_width)
            subset = [ nums[i] for i in range(len(nums)) if bitmask[i] == '1' ] 
            subsets.append(subset)
        return subsets
```

3rd
```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        all_subsets = [[]]
        for num in nums:
            new_subsets = [ subset + [num] for subset in all_subsets ]
            all_subsets.extend(new_subsets)
        return all_subsets
```

preorderの先頭がrootノードになる。inorderのrootノードの左がrootノードの左の部分木、右が右の部分木になる。
preorder: `[root, rootの左、rootの右]`
inorder: `[rootの左、root、rootの右]`


1st

`inorder.index`の計算量がO(n)なので全体でO(n^2)の計算量になる。
事前にvalueとindexの位置をマップで管理すればO(n)に減らせる。

```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        if preorder == []:
            return None
        root_value = preorder[0]
        root_index_in_inorder = inorder.index(root_value)
        num_of_left_node = root_index_in_inorder
        root = TreeNode(root_value)
        root.left = self.buildTree(preorder[1:1 + num_of_left_node], inorder[:root_index_in_inorder])
        root.right = self.buildTree(preorder[1 + num_of_left_node:], inorder[root_index_in_inorder + 1:])
        return root

```

2nd

`[left, right)`で対象のinorderの範囲を指定した再帰。preorderのどこを見るべきかはroot_indexで管理。
配列を引数で渡すより難しかった。

```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        value_to_inorder_index = {}
        for index, value in enumerate(inorder):
            value_to_inorder_index[value] = index
        
        def build_tree_in_preorder(left, right):
            nonlocal root_index
            if left >= right:
                return None
            root_value = preorder[root_index]
            root_index_in_inorder = value_to_inorder_index[root_value]
            root = TreeNode(root_value)
            root_index += 1
            root.left = build_tree_in_preorder(left, root_index_in_inorder)
            root.right = build_tree_in_preorder(root_index_in_inorder + 1, right)
            return root

        root_index = 0
        return build_tree_in_preorder(0, len(preorder))
```

3rd

```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        value_to_inorder_index = {}
        for index, value in enumerate(inorder):
            value_to_inorder_index[value] = index

        def build_tree(left, right):
            nonlocal preorder_root_index
            if left >= right:
                return None
            root_value = preorder[preorder_root_index]
            preorder_root_index += 1
            inorder_root_index = value_to_inorder_index[root_value]
            root = TreeNode(root_value)
            root.left = build_tree(left, inorder_root_index) 
            root.right = build_tree(inorder_root_index + 1, right)
            return root

        preorder_root_index = 0
        return build_tree(0, len(preorder))
```

文字を1文字ずつ読み進めれば良い。フェーズとしては以下の3つ
- 空白を無視して読み進める。
- 符号を判定する
- 数値を読んでいく

INT_MAX, INT_MINを超えたらそこで終了する。Pythonのintは理論上は上限がないので途中のオーバーフローなどは考えなくて良い。
CやC++で実装する場合でも32bitより大きい型（long）を確保してあげれば考えなくて良くなる。← ただlongの場合のオーバーフローの考慮などどこかではちゃんと考慮しないといけない。その場合は、桁上りの計算をする前にオーバーフローするかどうかを判定すれば良い。

> Integers have unlimited precision.

https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex

1st

isdigitの実装は https://github.com/python/cpython/blob/2305ca51448552542b2414186252123a8dc87db7/Lib/curses/ascii.py#L59
空白の判定には、`str.isspace()`も使用できる。LeetCodeの要件的には`' '`との比較だけで良い。

```python
class Solution:
    def myAtoi(self, s: str) -> int:
        def skip_white_spaces():
            index = 0
            while index < len(s) and s[index] == ' ':
                index += 1
            return index
        
        def get_sign(begin):
            index = begin
            if index == len(s):
                return index, 1
            if s[index] == '-':
                return index + 1, -1
            if s[index] == '+':
                return index + 1, 1
            return index, 1

        index = skip_white_spaces()
        index, sign = get_sign(index)

        INT_MAX = (1 << 31) - 1
        INT_MIN = - INT_MAX - 1

        number = 0
        while index < len(s) and s[index].isdigit():
            digit = ord(s[index]) - ord('0')
            number = number * 10 + sign * digit
            if number >= INT_MAX:
                return INT_MAX
            if number <= INT_MIN:
                return INT_MIN
            index += 1
        return number
```

2nd
```python
```


3rd
```python
```

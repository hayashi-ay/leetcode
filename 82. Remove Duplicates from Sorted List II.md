前回の問題と異なり重複がある場合は全てのノードを削除する必要がある。headノードも削除される可能性があるのでダミーノードを用意するのが良い。
1回のループで答えのリストを作るのが難しかったので、重複のないノードをリストに詰めてその後、答えのリストを作成する流れで書いた。

1st

```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        unique_nodes = []
        current_node = head
        while current_node:
            if current_node.next and current_node.val == current_node.next.val:
                current_value = current_node.val
                while current_node and current_node.val == current_value:
                    current_node = current_node.next
                continue
            unique_nodes.append(current_node)
            current_node = current_node.next
        if not unique_nodes:
            return None
        sentinel = ListNode()
        current_node = sentinel
        for node in unique_nodes:
            current_node.next = node
            current_node = current_node.next
        current_node.next = None
        return sentinel.next
```

2nd

重複を発見したら変えるな。2重ループ。
```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        sentinel = ListNode()
        last_unique_node = sentinel
        current_node = head
        while current_node:
            if current_node.next and current_node.val == current_node.next.val:
                value_to_remove = current_node.val
                while current_node and current_node.val == value_to_remove:
                    current_node = current_node.next
                continue
            last_unique_node.next = current_node
            last_unique_node = current_node
            current_node = current_node.next
        last_unique_node.next = None
        return sentinel.next
```

上を少し変えてwhileを抜けた後にlast_unique_node.next = Noneをしなくて良いようにした版。上の方がwhileループの中のlast_unique_nodeの更新場所が散らばらないので好み。
```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        sentinel = ListNode()
        sentinel.next = head
        last_unique_node = sentinel
        current_node = head
        while current_node:
            if current_node.next and current_node.val == current_node.next.val:
                value_to_remove = current_node.val
                while current_node and current_node.val == value_to_remove:
                    current_node = current_node.next
                last_unique_node.next = current_node
                continue
            last_unique_node = last_unique_node.next
            current_node = current_node.next
        return sentinel.next
```

重複を発見したら申し送る。1重ループ。
こっちの方が個人的には好みかも。処理が追いやすい気がする。

```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        sentinel = ListNode()
        last_unique_node = sentinel
        current_node = head
        value_to_remove = None
        while current_node:
            if current_node.val == value_to_remove:
                current_node = current_node.next
                continue
            if current_node.next and current_node.val == current_node.next.val:
                value_to_remove = current_node.val
                continue
            last_unique_node.next = current_node
            last_unique_node = last_unique_node.next
            current_node = current_node.next
        last_unique_node.next = None
        return sentinel.next
```

3rd

`if current_node.next and current_node.val == current_node.next.val:`のif文でcurrent_nodeも動かすかは迷った。「重複するノードを見つけました、あとはよろしく」というのは見つけたんだから処理もしてくれという気持ちにもなり少し気が利かないような気もするが、あくまでも重複を見つける担当として責務を明確にしておく方が読みやすい気もする。
動かす場合は2つ一気に動かせるので`current_node = current_node.next.next`と書ける。


```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        sentinel = ListNode()
        last_unique_node = sentinel
        current_node = head
        value_to_remove = None
        while current_node:
            if current_node.val == value_to_remove:
                current_node = current_node.next
                continue
            if current_node.next and current_node.val == current_node.next.val:
                value_to_remove = current_node.val
                continue
            last_unique_node.next = current_node
            last_unique_node = last_unique_node.next
            current_node = current_node.next
        last_unique_node.next = None
        return sentinel.next
```

↓追加（2024/02/15）

4th
2重ループ。関数に切り出してみた。

```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        def is_duplicated(node1, node2):
            return node1 and node2 and node1.val == node2.val
        
        def skip_nodes(start, value_to_skip):
            current = start
            while current:
                if current.val != value_to_skip:
                    break
                current = current.next
            return current

        sentinel = ListNode()
        last_unique_node = sentinel
        current = head
        while current:
            if is_duplicated(current, current.next):
                current = skip_nodes(current, current.val)
                last_unique_node.next = current
            else:
                last_unique_node.next = current
                last_unique_node = last_unique_node.next
                current = current.next
        return sentinel.next
```

1重ループ。`need_remove` と`value_to_remove`の2変数を定義したが後者だけで十分な気がする。

```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        def is_duplicated(node1, node2):
            return node1 and node2 and node1.val == node2.val

        sentinel = ListNode()
        last_unique_node = sentinel
        current = head
        need_remove = False
        value_to_remove = None
        while current:
            if need_remove and current.val == value_to_remove:
                pass
            elif is_duplicated(current, current.next):
                need_remove = True
                value_to_remove = current.val
            else:
                need_remove = False
                value_to_remove = None
                last_unique_node.next = current
                last_unique_node = last_unique_node.next
            current = current.next
        last_unique_node.next = None
        return sentinel.next
```

再帰でも書いた。意外とシンプル。
```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        def delete_duplicates(node, value_to_remove):
            if node is None:
                return None
            elif node.val == value_to_remove:
                return delete_duplicates(node.next, value_to_remove)
            elif node.next and node.val == node.next.val:
                return delete_duplicates(node.next, node.val)
            else:
                node.next = delete_duplicates(node.next, None)
                return node
        return delete_duplicates(head, None)
```

5th
```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        sentinel = ListNode()
        prev = sentinel
        current = head
        while current:
            if current.next and current.val == current.next.val:
                value_to_remove = current.val
                while current and current.val == value_to_remove:
                    current = current.next
                prev.next = current
            else:
                prev.next = current
                prev = prev.next
                current = current.next
        return sentinel.next
```

6th
二重ループ。関数に切り出したほうが見通しが良い。
whileの中のifをcontinueにするかif-elseにするのかは好みか。

```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        def skip_duplicated_nodes(node, value_to_remove):
            while node and node.val == value_to_remove:
                node = node.next
            return node

        sentinel = ListNode()
        current = head
        prev = sentinel
        while current:
            if current.next and current.val == current.next.val:
                current = skip_duplicated_nodes(current.next, current.val)
                prev.next = current
                continue
            prev.next = current
            prev = prev.next
            current = current.next
        return sentinel.next
```

1重ループ。うーん。if, elifの`prev.next = current`をwhileの外で`prev.next = None`にするようにすれば`current = current.next`を共通部分として括れるけど。
```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        sentinel = ListNode()
        current = head
        prev = sentinel
        value_to_remove = None
        while current:
            if current.val == value_to_remove:
                current = current.next
                prev.next = current
            elif current.next and current.val == current.next.val:
                value_to_remove = current.val
                current = current.next
                prev.next = current
            else:
                prev.next = current
                prev = prev.next
                current = current.next
        return sentinel.next
```

再帰
```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        def delete_duplicates(node, value_to_remove):
            if node is None:
                return None
            if node.val == value_to_remove:
                return delete_duplicates(node.next, value_to_remove)
            if node.next and node.val == node.next.val:
                return delete_duplicates(node.next, node.val)
            node.next = delete_duplicates(node.next, None)
            return node
        
        return delete_duplicates(head, None)
```

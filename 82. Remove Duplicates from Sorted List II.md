前回の問題と異なり重複がある場合は全てのノードを削除する必要がある。headノードも削除される可能性があるのでダミーノードを用意するのが良い。
1回のループで答えのリストを作るのが難しかったので、重複のないノードをリストに詰めてその後、答えのリストを作成する流れで書いた。

1st

```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        unique_nodes = []
        current_node = head
        while current_node:
            if current_node.next and current_node.val == current_node.next.val:
                current_value = current_node.val
                while current_node and current_node.val == current_value:
                    current_node = current_node.next
                continue
            unique_nodes.append(current_node)
            current_node = current_node.next
        if not unique_nodes:
            return None
        sentinel = ListNode()
        current_node = sentinel
        for node in unique_nodes:
            current_node.next = node
            current_node = current_node.next
        current_node.next = None
        return sentinel.next
```

2nd

重複を発見したら変えるな。2重ループ。
```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        sentinel = ListNode()
        last_unique_node = sentinel
        current_node = head
        while current_node:
            if current_node.next and current_node.val == current_node.next.val:
                value_to_remove = current_node.val
                while current_node and current_node.val == value_to_remove:
                    current_node = current_node.next
                continue
            last_unique_node.next = current_node
            last_unique_node = current_node
            current_node = current_node.next
        last_unique_node.next = None
        return sentinel.next
```

上を少し変えてwhileを抜けた後にlast_unique_node.next = Noneをしなくて良いようにした版。上の方がwhileループの中のlast_unique_nodeの更新場所が散らばらないので好み。
```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        sentinel = ListNode()
        sentinel.next = head
        last_unique_node = sentinel
        current_node = head
        while current_node:
            if current_node.next and current_node.val == current_node.next.val:
                value_to_remove = current_node.val
                while current_node and current_node.val == value_to_remove:
                    current_node = current_node.next
                last_unique_node.next = current_node
                continue
            last_unique_node = last_unique_node.next
            current_node = current_node.next
        return sentinel.next
```

重複を発見したら申し送る。1重ループ。
こっちの方が個人的には好みかも。処理が追いやすい気がする。

```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        sentinel = ListNode()
        last_unique_node = sentinel
        current_node = head
        value_to_remove = None
        while current_node:
            if current_node.val == value_to_remove:
                current_node = current_node.next
                continue
            if current_node.next and current_node.val == current_node.next.val:
                value_to_remove = current_node.val
                continue
            last_unique_node.next = current_node
            last_unique_node = last_unique_node.next
            current_node = current_node.next
        last_unique_node.next = None
        return sentinel.next
```

3rd

`if current_node.next and current_node.val == current_node.next.val:`のif文でcurrent_nodeも動かすかは迷った。「重複するノードを見つけました、あとはよろしく」というのは見つけたんだから処理もしてくれという気持ちにもなり少し気が利かないような気もするが、あくまでも重複を見つける担当として責務を明確にしておく方が読みやすい気もする。
動かす場合は2つ一気に動かせるので`current_node = current_node.next.next`と書ける。


```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        sentinel = ListNode()
        last_unique_node = sentinel
        current_node = head
        value_to_remove = None
        while current_node:
            if current_node.val == value_to_remove:
                current_node = current_node.next
                continue
            if current_node.next and current_node.val == current_node.next.val:
                value_to_remove = current_node.val
                continue
            last_unique_node.next = current_node
            last_unique_node = last_unique_node.next
            current_node = current_node.next
        last_unique_node.next = None
        return sentinel.next
```

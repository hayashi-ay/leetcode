## 概要

> Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp.
> 
> Implement the `TimeMap` class:
> 
> - `TimeMap()` Initializes the object of the data structure.
> - `void set(String key, String value, int timestamp)` Stores the key `key` with the value `value` at the given time `timestamp`.
> - `String get(String key, int timestamp)` Returns a value such that `set` was called previously, with `timestamp_prev <= timestamp`. If there are multiple such values, it returns the value associated with the largest `timestamp_prev`. If there are no values, it returns `""`.

## 方針
### Intuition
ハッシュマップを使いvalueとしてkeyとtimestampの組み合わせを持つのが良い。複数のkeyとtimestampをどう管理するかが問題になる。timestampでの検索は正確な値ではなく指定された値以下という形で用いられるのでtimestampをkeyにしたハッシュマップは検索性能は良くない。課題文にtimestampは昇順になるとあるので素直に配列で持たせるのが良さそう。

### HashMap + LinerSearch

```python
class TimeMap:

    def __init__(self):
        self.time_map = {} # {key: (timestamp, value)}

    def set(self, key: str, value: str, timestamp: int) -> None:
        if key not in self.time_map:
            self.time_map[key] = []
        self.time_map[key].append((timestamp, value))            

    def get(self, key: str, timestamp: int) -> str:
        if key not in self.time_map:
            return ""
        values = self.time_map[key]
        for idx in range(len(values) - 1, -1, -1):
            timestamp_prev, value = values[idx]
            if timestamp_prev <= timestamp:
                return value
        return ""
```

### HashMap + BinarySearch

```python
class TimeMap:

    def __init__(self):
        self.time_map = {} # {key: (timestamp, value)}

    def set(self, key: str, value: str, timestamp: int) -> None:
        if key not in self.time_map:
            self.time_map[key] = []
        self.time_map[key].append((timestamp, value))            

    def get(self, key: str, timestamp: int) -> str:
        if key not in self.time_map:
            return ""
        values = self.time_map[key]

        def find_upper_bound(values, timestamp):
            left, right = 0, len(values)
            while left < right:
                mid = (left + right) // 2
                timestamp_prev = values[mid][0]
                if timestamp_prev <= timestamp:
                    left = mid + 1
                else:
                    right = mid
            return left

        upper_bound = find_upper_bound(values, timestamp)
        if upper_bound > 0:
            return values[upper_bound - 1][1]
        return ""
```

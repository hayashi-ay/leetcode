heapを使うのが良い。

1st

時間計算量は、`__init__`がO(n logk)でaddがO(logk)になる。`n = len(nums)`
空間計算量は、O(k)

```python
class KthLargest:

    def __init__(self, k: int, nums: List[int]):
        self.k = k
        self.min_heap = []
        for num in nums:
            heapq.heappush(self.min_heap, num)
            if len(self.min_heap) > self.k:
                heapq.heappop(self.min_heap)

    def add(self, val: int) -> int:
        heapq.heappush(self.min_heap, val)
        if len(self.min_heap) > self.k:
            heapq.heappop(self.min_heap)
        return self.min_heap[0]
```


2nd

heapを自前で実装した版。

```python
# Docs: https://docs.python.org/3/library/heapq.html
# ref: https://github.com/python/cpython/blob/a8e93d3dca086896e668b88b6c5450eaf644c0e7/Lib/heapq.py
class MyHeap:
    def __init__(self, items = None):
        if items is None:
            items = []
        self.min_heap = items
        for i in reversed(range(len(self.min_heap) // 2)):
            self._sift_up(i)

    def __len__(self):
        return len(self.min_heap)
        

    def push(self, item):
        self.min_heap.append(item)
        self._sift_down(len(self.min_heap) - 1)
    
    def pop(self):
        if len(self.min_heap) <= 1:
            return self.min_heap.pop()
        last_item = self.min_heap.pop()
        smallest = self.min_heap[0]
        self.min_heap[0] = last_item
        self._sift_up(0)
        return smallest

    def top(self):
        return self.min_heap[0]

    # posの親を頂点まで辿っていきposより大きい値の場合はふるい落とす
    def _sift_down(self, pos):
        item = self.min_heap[pos]
        while pos > 0:
            parent_pos = (pos - 1) >> 1
            parent_item = self.min_heap[parent_pos]
            if item >= parent_item:
                break
            self._swap_item(pos, parent_pos)
            pos = parent_pos

    # posから子を辿っていき、posより小さい場合はふるい上げる
    def _sift_up(self, pos):
        def min_item_pos(left_child_pos, righht_child_pos):
            if self.min_heap[left_child_pos] < self.min_heap[right_child_pos]:
                return left_child_pos
            else:
                return right_child_pos

        child_pos = pos * 2 + 1
        while child_pos < len(self.min_heap):
            right_child_pos = child_pos + 1
            if right_child_pos < len(self.min_heap):
                child_pos = min_item_pos(child_pos, right_child_pos)
            # 実際はこのearly returnはそこまで効果がない。CPythonのコメント参照。
            if self.min_heap[child_pos] >= self.min_heap[pos]:
                break
            self._swap_item(child_pos, pos)
            pos = child_pos
            child_pos = child_pos * 2 + 1
    
    def _swap_item(self, pos1, pos2):
        self.min_heap[pos1], self.min_heap[pos2] = self.min_heap[pos2], self.min_heap[pos1]

class KthLargest:

    def __init__(self, k: int, nums: List[int]):
        self.k = k
        self.my_heap = MyHeap()
        for num in nums:
            self.my_heap.push(num)
            if len(self.my_heap) > self.k:
                self.my_heap.pop()

    def add(self, val: int) -> int:
        self.my_heap.push(val)
        if len(self.my_heap) > self.k:
            self.my_heap.pop()
        return self.my_heap.top()
```

3rd

```python
class KthLargest:

    def __init__(self, k: int, nums: List[int]):
        self.k = k
        self.min_heap = []
        for num in nums:
            heapq.heappush(self.min_heap, num)
            if len(self.min_heap) > self.k:
                heapq.heappop(self.min_heap)

    def add(self, val: int) -> int:
        heapq.heappush(self.min_heap, val)
        if len(self.min_heap) > self.k:
            heapq.heappop(self.min_heap)
        return self.min_heap[0]
```

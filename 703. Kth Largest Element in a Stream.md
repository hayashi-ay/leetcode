heapを使うのが良い。

1st

時間計算量は、`__init__`がO(n logk)でaddがO(logk)になる。`n = len(nums)`
空間計算量は、O(k)

```python
class KthLargest:

    def __init__(self, k: int, nums: List[int]):
        self.k = k
        self.min_heap = []
        for num in nums:
            heapq.heappush(self.min_heap, num)
            if len(self.min_heap) > self.k:
                heapq.heappop(self.min_heap)

    def add(self, val: int) -> int:
        heapq.heappush(self.min_heap, val)
        if len(self.min_heap) > self.k:
            heapq.heappop(self.min_heap)
        return self.min_heap[0]
```


2nd

heapを自前で実装した版。

```python
# Docs: https://docs.python.org/3/library/heapq.html
# ref: https://github.com/python/cpython/blob/a8e93d3dca086896e668b88b6c5450eaf644c0e7/Lib/heapq.py
class MyHeqp:
    def __init__(self):
        self.min_heap = []

    def push(self, item):
        self.min_heap.append(item)
        self._sift_down(len(self.min_heap), 0)
    
    def pop(self) -> int:
        if self.min_heap == []:
            raise IndexError()
        if len(self.min_heap) == 1:
            return self.min_heap.pop()
        last_item = self.min_heap.pop()
        smallest = self.min_heap[0]
        self.min_heap[0] = last_item
        self._sift_up(0)
        return smallest

    # posの親をend_posまで辿っていきposより大きい値の場合はふるい落とす
    def _sift_down(self, pos, end_pos):
        item = self.min_heap[pos]
        while pos > end_pos:
            parent_pos = (pos - 1) >> 1
            parent_item = self.min_heap[parent_pos]
            if item >= parent_item:
                break
            self._swap_item(pos, parent_pos)
            pos = parent_pos

    # posから子を辿っていき、posより小さい場合はふるい上げる
    def _sift_up(self, pos):
        #
    
    def _swap_item(self, pos1, pos2):
        self.min_heap[pos1], self.min_heap[pos2] = self.min_heap[pos2], self.min_heap[pos1]

class KthLargest:

    def __init__(self, k: int, nums: List[int]):
        self.k = k
        self.min_heap = []
        for num in nums:
            heapq.heappush(self.min_heap, num)
            if len(self.min_heap) > self.k:
                heapq.heappop(self.min_heafp)

    def add(self, val: int) -> int:
        heapq.heappush(self.min_heap, val)
        if len(self.min_heap) > self.k:
            heapq.heappop(self.min_heap)
        return self.min_heap[0]
```

3rd

```python
```

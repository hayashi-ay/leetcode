愚直にやると総当たりで全てのsubsequenceについて試せば良いが計算量が $O(2^n)$ になるので現実的ではない。
求めたいのが最大長で、かつ現在の状態がそれまでの状態に依存するのでDPの問題として解くと良い。

自分より左側の各インデックスに対して、その後ろに自分が来ることを考えれば良い。
例）「10, 9, 2, 3 ...」のとき3に注目する場合はそれぞれ「10, 3」、「9, 3」、「2, 3」というsubsequentを考える
LISが成立しない場合はskip、成立する場合は該当のインデックス時点の最大値にプラス1をすれば良い。

1st

Time Complexity: $O(n^2)$
Space Complexity: $O(n)$

考察に10分以上時間が掛かった

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        lengths = [1] * len(nums)
        for cur_idx in range(1, len(nums)):
            for left_idx in range(cur_idx):
                if nums[cur_idx] > nums[left_idx]:
                    lengths[cur_idx] = max(lengths[cur_idx], lengths[left_idx] + 1)
        return max(lengths)
```

2nd

インデックスの命名をi, jにした代わりにコメントを追加した。↑だと`cur_idx`、`left_idx`にしたがそこまで可読性が上がらなかった気がする。

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        lengths = [1] * len(nums)
        for i in range(1, len(nums)):
            for j in range(i):
                # 自分の左より値が大きい場合はsubsequenceに加える
                if nums[i] > nums[j]:
                    lengths[i] = max(lengths[i], lengths[j] + 1)
        return max(lengths)
```

3rd

1st, 2ndとほぼ同じ。
```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        lengths = [1] * len(nums)
        for i in range(1, len(nums)):
            for j in range(i):
                if nums[i] > nums[j]:
                    lengths[i] = max(lengths[i], lengths[j] + 1)
        return max(lengths)
```

> うーん、読みにくいと思ったんですが、理由が
lengths
の意味がパズルになっているからだと思いました。
日本語で長々と書くと、「lengths[i] とは、仮に nums[i] がシーケンスの最後であると仮定した場合に可能な、最も長いシーケンスの長さ」ですよね。
まあ、「長さ(複数)」であることには間違いないですが、「長さ」とだけいわれて、ああ「仮に nums[i] がシーケンスの最後であると仮定した場合に可能な、最も長いシーケンスの長さ」ってことね、とならず、それを推測するパズルになっています。
これを前提とすると、内側のループは、関数にすることができるはずで、「i よりも左で、nums[i] 未満で終わる最大のシーケンスの長さ」を返させればいいですね。

4th

1stのブラッシュアップ版

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        def get_max_lis_length_before_idx(right):
            max_length = 0
            for i in range(right):
                if nums[i] < nums[right]:
                    max_length = max(max_length, lis_lengths[i])
            return max_length
        
        lis_lengths = [1] * len(nums)
        for i in range(1, len(nums)):
            lis_lengths[i] = get_max_lis_length_before_idx(i) + 1
        return max(lis_lengths)
```

LISの末尾のみを考慮する版。
追加の考察。要は自分の左側にあり、末尾が自分より小さいLISの中で最大長のものを探し出せば良い。

```
例）[2, 6, 8, 4, 5, 3]という配列があるとき
5の左側にあるLISは、それぞれの長さで以下の3つある。もちろん長さ1の場合は[6], [8], [4]などもあるが、同じ長さでは末尾が1番小さくなるLISのみを考えれば良い。
長さ1 [2]
長さ2 [2, 4]
長さ3 [2, 6, 8]

長さ2のLISの末尾が4で5より小さいので5の左側にあるLISの最大長は2であり、5が末尾となるLISの長さは3になる。
それぞれの長さのLISを管理すればよいが、末尾だけを考えれば良い。実際のsubsequenceと値は変わるが長さは一致する。なぜなら長さはsubsequenceの末尾より大きい値が来たときのみ更新されるので。
```

`lis_tails`は昇順なので2分探索できるが一旦Linerに探索する

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        def find_first_idx_greater_than_target(target):
            i = 0
            while target > lis_tails[i]:
                i += 1
            return i

        lis_tails = [nums[0]]
        for i in range(1, len(nums)):
            if nums[i] > lis_tails[-1]:
                lis_tails.append(nums[i])
                continue
            idx = find_first_idx_greater_than_target(nums[i])
            lis_tails[idx] = nums[i]
            
        return len(lis_tails)
```

5th

4thをブラッシュアップ

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        def find_max_lis_length_below_limit(end, limit):
            length = 0
            for i in range(end):
                if nums[i] < limit:
                    length = max(length, max_lis_lengths_ending_with_itself[i])
            return length

        max_lis_lengths_ending_with_itself = []
        for i in range(len(nums)):
            length = find_max_lis_length_below_limit(i, nums[i])
            max_lis_lengths_ending_with_itself.append(length + 1)
        return max(max_lis_lengths_ending_with_itself)
```

> max_lis_lengths_ending_with_itself
本当は、これもなんかあるんでしょうが、難しいですね。
longest_subsequence_using_the_index_as_tail
とか長過ぎますかねえ。
面接の場だったら、私はなんとしたらいいかよく分からないから教えて欲しいとか、コメントに詳細を書いておきたいとか言うんだと思います。

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        def find_first_greater_index(target):
            i = 0
            while target > lis_tails[i]:
                i += 1
            return i

        lis_tails = [nums[0]]
        for num in nums[1:]:
            if num > lis_tails[-1]:
                lis_tails.append(num)
                continue
            idx = find_first_greater_index(num)
            lis_tails[idx] = num
        return len(lis_tails)
```

> `lis_tails = [nums[0]]`
まあ、もうちょっと名前を工夫しますか?
minimum_tail_value_of_lis_of_length
とか。



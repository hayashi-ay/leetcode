とりあえず全通り試してみるのが良さそう？

1st

backtracking。TLEになった。
```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        if s == "":
            return True
        for word in wordDict:
            if not s.startswith(word):
                continue
            if self.wordBreak(s[len(word):], wordDict):
                return True
        return False
```

これもTLE。wordDictの文字から始まるかどうかをTrieにした。`n = len(wordDict), m = len(wordDict[i])`とするとループの部分の計算量をO(nm)からO(m)に減らせたはず。
```python
class PrefixTreeNode:
    def __init__(self):
        self.children = {}
        self.is_word = False

class PrefixTree:
    def __init__(self):
        self.root = PrefixTreeNode()
    
    def insert(self, word):
        current = self.root
        for c in word:
            if c not in current.children:
                current.children[c] = PrefixTreeNode()
            current = current.children[c]
        current.is_word = True
    
    def search(self, word):
        current = self.root
        for c in word:
            if c not in current.children:
                return False
            current = current.children[c]
        return current.is_word
    
    def get_all_prefixes(self, string):
        prefixes = []
        current = self.root
        word = ""
        for c in string:
            if c not in current.children:
                break
            current = current.children[c]
            word += c
            if current.is_word:
                prefixes.append(word)
        return prefixes
    

class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        trie = PrefixTree()
        for word in wordDict:
            trie.insert(word)

        def backtrack(s):
            if s == "":
                return True
            for word in trie.get_all_prefixes(s):
                if backtrack(s[len(word):]):
                    return True
            return False
        
        return backtrack(s)
```

2nd


3rd

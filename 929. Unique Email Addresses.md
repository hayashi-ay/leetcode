@マーク前の`.`は無視する。`+`が登場すれば@マークまですべて無視する。
上記のルールでEmailアドレスを正規化して、正規化後の総数を数えれば良い。

1st

関数に切り出したのでメインの処理の見通しはかなり良い。`canonicalize_email`内の処理はなんかごちゃごちゃしてるかも。
`elif exist_plus`と`elif c == "."`、`if not is_local`と`else`など同じ処理をしている部分は共通化もできそう。
if文をネストさせなかったがネストさせた方が構造がより分かりやすくなるかも。いまは処理が散らばっている感じがある。どれがローカルパートの処理でどれがドメインパートの処理かが分かりにくいかも。

```python
class Solution:
    def numUniqueEmails(self, emails: List[str]) -> int:
        def canonicalize_email(before):
            after = ""
            is_local = True
            exist_plus = False
            for c in before:
                if not is_local:
                    after += c
                elif c == "@":
                    is_local = False
                    after += c
                elif exist_plus:
                    pass
                elif c == "+":
                    exist_plus = True
                elif c == ".":
                    pass
                else:
                    after += c
            return after

        unique_emails = set()
        for email in emails:
            unique_emails.add(canonicalize_email(email))
        return len(unique_emails)
```

2nd

splitと組み合わせてみた。課題文で@がかならず1つだけ存在することが保証されているのでsplitの結果の長さを確認せずに`local, domain`に代入している。
splitを使う解法は楽だが@が複数入ってくるケースなど要件が変わると対応しづらそうな気がする。

```python
class Solution:
    def numUniqueEmails(self, emails: List[str]) -> int:
        def canonicalize_email(before):
            after = ""
            local, domain = before.split("@")
            for c in local:
                if c == "+":
                    break
                if c == ".":
                    continue
                after += c
            after += "@"
            after += domain
            return after

        unique_emails = set()
        for email in emails:
            unique_emails.add(canonicalize_email(email))
        return len(unique_emails)
```

if文をネストさせてみた。ローカルパートとドメインパートでそれぞれ処理しているのが分かりやすくなった気がする。
ifの中のelseとelseで同じ処理をしているので共通化することができる。↓後続の解法
```python
class Solution:
    def numUniqueEmails(self, emails: List[str]) -> int:
        def canonicalize_email(before):
            after = ""
            is_local_part = True
            skip_until_at_mark = False
            for c in before:
                if is_local_part:
                    if c == "@":
                        is_local_part = False
                        skip_until_at_mark = False
                        after += c
                    elif skip_until_at_mark or c == ".":
                        pass
                    elif c == "+":
                        skip_until_at_mark = True
                    else:
                        after += c
                else:
                    after += c
            return after

        unique_emails = set()
        for email in emails:
            unique_emails.add(canonicalize_email(email))
        return len(unique_emails)
```

結構すっきりした。とはいえ個人的には2ndの2つ目や1stの方が処理が分かりやすい気がする。
```python
class Solution:
    def numUniqueEmails(self, emails: List[str]) -> int:
        def canonicalize_email(before):
            after = ""
            is_local_part = True
            skip_until_at_mark = False
            for c in before:
                if is_local_part:
                    if c == "@":
                        is_local_part = False
                        skip_until_at_mark = False
                    elif skip_until_at_mark or c == ".":
                        continue
                    elif c == "+":
                        skip_until_at_mark = True
                        continue
                after += c
            return after

        unique_emails = set()
        for email in emails:
            unique_emails.add(canonicalize_email(email))
        return len(unique_emails)
```

3rd

結局2-3とほぼ同じに落ち着いた。

```python
class Solution:
    def numUniqueEmails(self, emails: List[str]) -> int:
        def canonicalize(before):
            after = ""
            is_local_part = True
            need_skip = False
            for c in before:
                if is_local_part:
                    if c == "@":
                        is_local_part = False
                        need_skip = False
                    elif need_skip or c == ".":
                        continue
                    elif c == "+":
                        need_skip = True
                        continue
                after += c
            return after

        unique_emails = set()
        for email in emails:
            unique_emails.add(canonicalize(email))
        return len(unique_emails)
```

4th

文字列操作関数。入力値に@マークが必ず1つだけ入ることに強く依存している。安全に書くなら`parts = email.split("@")`と配列として受け取った後に`len(parts) == 2`でなければ弾けば良い。
dotsを取り除くのはfilterよりreplaceが良さそう

```python
class Solution:
    def numUniqueEmails(self, emails: List[str]) -> int:
        def canonicalize(email):
            local, domain = email.split("@")
            local_ignore_alias = local.split("+")[0]
            local_without_dots = "".join(filter(lambda c: c != ".", local_ignore_alias))
            return local_without_dots + "@" + domain

        unique_emails = set()
        for email in emails:
            unique_emails.add(canonicalize(email))
        return len(unique_emails)
```

replaceを使うようにした＆f-stringsを使うようにした。

```python
class Solution:
    def numUniqueEmails(self, emails: List[str]) -> int:
        def canonicalize(email):
            local, domain = email.split("@")
            canonicalized_local = local.split("+")[0].replace(".", "")
            return f"{canonicalized_local}@{domain}"

        unique_emails = set()
        for email in emails:
            unique_emails.add(canonicalize(email))
        return len(unique_emails)
```

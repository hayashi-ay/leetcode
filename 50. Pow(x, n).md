1st

愚直にn回掛けるのは大変なので、半々にしていく。2^4 -> 4^2みたいなイメージ。
時間、空間計算量はlog(n)になる。

最後のif-elseのelseはなくても良いが、elseがある方がn%2との対比がはっきりすると思い残している。
```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
        if n == 0:
            return 1
        if n < 0:
            return 1 / self.myPow(x, -n)
        if n % 2:
            return x * self.myPow(x * x, n // 2)
        else:
            return self.myPow(x * x, n // 2)
```

> return 1 / self.myPow(x, -n)のとこreturn self.myPow(1 / x, -n)で良いかも

2nd

binary exponentationだが1stとは発想が違う。各桁について掛けていく。
重みが前の桁の重みの二乗になるので使い回せる。
3^14 = 3^(8 + 4 + 2) = 3^8 * 3^4 * 3^2

right to left
```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
        if n == 0:
            return 1
        if n < 0:
            return self.myPow(1 / x, -n)
        res = 1
        digits = x
        while n:
            if n & 1:
                res *= digits
            digits *= digits
            n >>= 1
        return res
```

> digitsよりweightとかの方が良いかも。

left to right
CPythonのpowはこの方法。数が多いときはk-ary sliding windowでwindowサイズずつ計算していく。
```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
        if n == 0:
            return 1
        if n < 0:
            return self.myPow(1 / x, -n)
        # nの最上位bitが1になるようにする
        bit = 1 << (n.bit_length() - 1)
        res = 1
        while bit > 0:
            res *= res
            if n & bit:
                res *= x
            bit >>= 1
        return res
```

3rd

半々にしていくのが１番簡単。
```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
        if n == 0:
            return 1
        if n < 0:
            return self.myPow(1 / x, -n)
        if n % 2:
            return x * self.myPow(x * x, n // 2)
        else:
            return self.myPow(x * x, n // 2)
```

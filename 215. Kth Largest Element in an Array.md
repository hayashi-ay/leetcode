## 概要
> Given an integer array `nums` and an integer `k`, return _the_ `kth` _largest element in the array_.
> 
> Note that it is the `kth` largest element in the sorted order, not the `kth` distinct element.
> 
> Can you solve it without sorting?

## 方針
### Intuition

### heap
Time Complexity: $O(n\log k)$
Space Complexity: $O(k)$
Where: `n = len(nums)`

```python
def findKthLargest(self, nums: List[int], k: int) -> int:
	minH = []
	for n in nums:
		heapq.heappush(minH, n)
		if len(minH) > k:
			heapq.heappop(minH)
	return minH[0]
```

### Quickselect
Time Complexity: $O(n)$, worst case: $O(n^2)$
Space Complexity: $O(1)$
Where: `n = len(nums)`

↓ numsが大きくかつほとんど同じ値からなる場合にTLEになるようになってしまった

```python
def findKthLargest(self, nums: List[int], k: int) -> int:
	def partition(left, right, pivotIndex):
		pivot = nums[pivotIndex]
		sortedIndex = left
		# move pivot to the end
		nums[pivotIndex], nums[right] = nums[right], nums[pivotIndex]
		# move smaller element to right
		for i in range(left , right):
			if nums[i] >= pivot:
				nums[i], nums[sortedIndex] = nums[sortedIndex], nums[i]
				sortedIndex += 1
		# get back pivot
		nums[sortedIndex], nums[right] = nums[right], nums[sortedIndex]
		return sortedIndex

	def quickselect(left, right, k):
		# pivotIndex = (left + right) // 2
		pivotIndex = random.randint(left, right)
		pivotIndex = partition(left, right, pivotIndex)
		if pivotIndex == k:
			return
		elif pivotIndex > k:
			quickselect(left, pivotIndex - 1, k)
		else:
			quickselect(pivotIndex + 1, right, k)
	
	n = len(nums)
	quickselect(0, n - 1, k - 1)
	return nums[k - 1]
```

```python
def findKthLargest(self, nums: List[int], k: int) -> int:
	def quickselect(nums, kth_largest):
		pivot = random.choice(nums)
		higher, equals, lower = [], [], []
		for num in nums:
			if num > pivot:
				higher.append(num)
			elif num == pivot:
				equals.append(num)
			else:
				lower.append(num)
		if len(higher) >= kth_largest:
			return quickselect(higher, kth_largest)
		if len(higher) + len(equals) < kth_largest:
			return quickselect(lower, kth_largest - len(higher) - len(equals))
		return pivot
	return quickselect(nums, k)
```
### Counting Sort
Time Complexity: $O(n + m)$
Space Complexity: $O(n + m)$
Where: `n = len(nums), m = max(nums) - min(nums)`

```python
def findKthLargest(self, nums: List[int], k: int) -> int:
	min_value = min(nums)
	max_value = max(nums)

	counts = [0] * (max_value - min_value + 1)
	for num in nums:
		count_index = num - min_value
		counts[count_index] += 1
	
	num_of_elements = 0
	for idx in range(len(counts) - 1, -1, -1):
		num_of_elements += counts[idx]
		if num_of_elements >= k:
			return idx + min_value
	return -1
```

愚直にやるなら累積和を出して各累積和同士の差を見ていけば良い。これだと $O(n^2)$
あとはDPとか。自分を含む最大長のsubarrayを求めて上げれば、各インデックスでは前回に自分を追加 or 新しくsubarrayを始めるの2択

1st

累積和同士の差を見る。TLE。
```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        prefix_sums = [0] * (len(nums) + 1)
        for i in range(len(nums)):
            prefix_sums[i + 1] = prefix_sums[i] + nums[i]
        
        max_sum = -inf
        for i in range(len(prefix_sums) - 1):
            for j in range(i + 1, len(prefix_sums)):
                subarray_sum = prefix_sums[j] - prefix_sums[i]
                max_sum = max(max_sum, subarray_sum)
        return max_sum
```

DP。変数名が長い。
```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        max_subarray_using_the_index_as_tail = [0] * len(nums)
        max_subarray_using_the_index_as_tail[0] = nums[0]
        for i in range(1, len(nums)):
            if max_subarray_using_the_index_as_tail[i - 1] <= 0:
                max_subarray_using_the_index_as_tail[i] = nums[i]
                continue
            max_subarray_using_the_index_as_tail[i] = max_subarray_using_the_index_as_tail[i - 1] + nums[i]
        return max(max_subarray_using_the_index_as_tail)
```

2nd

DP。空間計算量が $O(1)$ 
```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        max_subarray_using_the_index_as_tail = nums[0]
        max_len = nums[0]
        for i in range(1, len(nums)):
            max_subarray_using_the_index_as_tail = max(max_subarray_using_the_index_as_tail + nums[i], nums[i])
            max_len = max(max_len, max_subarray_using_the_index_as_tail)
        return max_len
```

Divide and Conquer。計算量は $O(n\ log\ n)$ だがLeetCodeの解法にあった。
midを使う or 左半分 or 右半分のどれかが最大になる。累積和を使うとインデックスのアクセスが混乱して難しかった。

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        prefix_sums = [0] * (len(nums) + 1)
        for i in range(len(nums)):
            prefix_sums[i + 1] = prefix_sums[i] + nums[i]

        def find_max_subarray(left, right):
            if not (left <= right):
                return -inf
            mid = (left + right) // 2
            best_left_sum = 0
            best_right_sum = 0
            for i in range(mid, left - 1, -1):
                best_left_sum = max(best_left_sum, prefix_sums[mid] - prefix_sums[i])
            for i in range(mid, right + 1):
                best_right_sum = max(best_right_sum, prefix_sums[i + 1] - prefix_sums[mid + 1])
            use_mid = best_left_sum + nums[mid] + best_right_sum

            only_left = find_max_subarray(left, mid - 1)
            only_right = find_max_subarray(mid + 1, right)
            return max(use_mid, only_left, only_right)
            
        return find_max_subarray(0, len(nums) - 1)
```

3rd

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        max_sum_using_the_index_as_tail = nums[0]
        max_sum = nums[0]
        for i in range(1, len(nums)):
            max_sum_using_the_index_as_tail = max(nums[i], nums[i] + max_sum_using_the_index_as_tail)
            max_sum = max(max_sum, max_sum_using_the_index_as_tail)
        return max_sum
```

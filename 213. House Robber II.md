「House Robber I」と違って家が直線上ではなくて円上になっている。1番目の家に強盗に入るパターンと入らないパターンの2つでDPをすれば良い？

1st

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) <= 2:
            return max(nums)

        max_amount_rob_first = [0] * len(nums)
        max_amount_not_rob_first = [0] * len(nums)

        # 最初の2軒について
        max_amount_rob_first[0] = nums[0]
        max_amount_rob_first[1] = nums[0]
        max_amount_not_rob_first[1] = nums[1]

        # 途中の家
        for i in range(2, len(nums) - 1):
            max_amount_rob_first[i] = max(max_amount_rob_first[i - 2] + nums[i], max_amount_rob_first[i - 1])
            max_amount_not_rob_first[i] = max(max_amount_not_rob_first[i - 2] + nums[i], max_amount_not_rob_first[i - 1])

        # 最後の家
        i = len(nums) - 1
        max_amount_not_rob_first[i] = max(max_amount_not_rob_first[i - 2] + nums[i], max_amount_not_rob_first[i - 1])
        max_amount_rob_first[i] = max_amount_rob_first[i - 1]

        return max(max_amount_rob_first[len(nums) - 1], max_amount_not_rob_first[len(nums) - 1])
```


2nd

LeetCodeの解法を見た。最初の家を除くlist、最後の家を除くlistについて考えれば直線に並んでいるものとして考えられる。
```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return nums[0]

        def rob_houses_in_line(nums):
            if len(nums) == 1:
                return nums[0]
            max_amount = [0] * len(nums)
            max_amount[0] = nums[0]
            max_amount[1] = max(nums[0], nums[1])
            for i in range(2, len(nums)):
                max_amount[i] = max(max_amount[i - 2] + nums[i], max_amount[i - 1])
            return max_amount[len(nums) - 1]

        return max(rob_houses_in_line(nums[1:]), rob_houses_in_line(nums[:-1]))
```

3rd

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return nums[0]

        def rob_houses_in_line(nums):
            if len(nums) == 1:
                return nums[0]
            max_amount = [0] * len(nums)
            max_amount[0] = nums[0]
            max_amount[1] = max(nums[0], nums[1])
            for i in range(2, len(nums)):
                max_amount[i] = max(max_amount[i - 2] + nums[i], max_amount[i - 1])
            return max_amount[len(nums) - 1]

        return max(rob_houses_in_line(nums[1:]), rob_houses_in_line(nums[:-1]))
```

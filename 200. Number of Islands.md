グラフの問題。ノードに訪れたかどうかは別途listなりdictで管理しても良いし、元のlistを書き換えても良い。
グループ化してるので、Union Findでも解けるかも？

1st

`mark_land_as_visited`の命名は迷った。実際はvisitedとしてマークしてるのではなくwaterにしてるのでやってることが若干違うがいい命名が思いつかなかった。
まあ実質やりたいこととしてはvisitedかどうかの記録でそのためにdictで管理するか元のlistを書き換えるかは細かい実装なので気にしなくても良いかも。←ただ破壊的な関数なので命名時点で分かった方が良いかも。
`1`, `0`は定数として別途定義して上げても良い。

```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        def mark_land_as_visited(row, col):
            if not (0 <= row < m and 0 <= col < n):
                return
            if grid[row][col] == '0':
                return
            grid[row][col] = '0'
            directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
            for dr, dc in directions:
                mark_land_as_visited(row + dr, col + dc)

        m, n = len(grid), len(grid[0])
        num_of_islands = 0
        for i in range(m):
            for j in range(n):
                # find a new islands
                if grid[i][j] == '1':
                    num_of_islands += 1
                    mark_land_as_visited(i, j)
        return num_of_islands
```

2nd

1stを非破壊的に。別途listで訪れたかどうかを管理。
LAND、WATERを定数として定義してあげる方が脳のワーキングメモリを節約できる。マジックナンバーのままだと読む際にも書く際にも負荷が少しある。
```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        def mark_land_as_visited(row, col):
            if not (0 <= row < height and 0 <= col < width):
                return
            if visited[row][col] or grid[row][col] == WATER:
                return
            visited[row][col] = True
            mark_land_as_visited(row - 1, col)
            mark_land_as_visited(row + 1, col)
            mark_land_as_visited(row, col - 1)
            mark_land_as_visited(row, col + 1)

        LAND = '1'
        WATER = '0'
        height, width = len(grid), len(grid[0])

        visited = [ [False] * width for _ in range(height)]
        num_of_islands = 0
        for row in range(height):
            for col in range(width):
                if grid[row][col] == LAND and not visited[row][col]:
                    num_of_islands += 1
                    mark_land_as_visited(row, col)
        return num_of_islands
```

BFS
```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        def remove_connected_land(start_row, start_col):
            lands = deque([(start_row, start_col)])
            while lands:
                row, col = lands.popleft()
                if grid[row][col] == WATER:
                    continue
                grid[row][col] = WATER
                dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]
                for dr, dc in dirs:
                    next_row, next_col = row + dr, col + dc
                    if not (0 <= next_row < m and 0 <= next_col < n):
                        continue
                    if grid[next_row][next_col] == WATER:
                        continue
                    lands.append((next_row, next_col))
                
        LAND = '1'
        WATER = '0'
        m, n = len(grid), len(grid[0])
        num_of_islands = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == LAND:
                    num_of_islands += 1
                    remove_connected_land(i, j)
        return num_of_islands
```

Union Find。実装結構大変だった。Union Findの効率化は経路圧縮のみでUnion by Rankはしていない。
```python
class UnionFind:
    def __init__(self, size):
        self.groups = [i for i in range(size)]
    
    def find(self, node):
        while self.groups[node] != node:
            self.groups[node] = self.find(self.groups[node])
        return self.groups[node]
    
    def union(self, node1, node2):
        group1 = self.find(node1)
        group2 = self.find(node2)
        if group1 == group2:
            return 0
        self.groups[group1] = group2
        return 1


class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        def count_lands():
            num = 0
            for i in range(m):
                for j in range(n):
                    if grid[i][j] == LAND:
                        num += 1
            return num
        
        def union_connected_land(uf, row, col):
            connected_num = 0
            dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]
            for dr, dc in dirs:
                next_row, next_col = row + dr, col + dc
                if not (0 <= next_row < m and 0 <= next_col < n):
                    continue
                if grid[next_row][next_col] == WATER:
                    continue
                connected_num += uf.union(row * m + col, next_row * m + next_col)
            return connected_num
                

        LAND = '1'
        WATER = '0'
        m, n = len(grid), len(grid[0])
        uf = UnionFind(m * n)
        num_of_lands = count_lands()
        for i in range(m):
            for j in range(n):
                if grid[i][j] == LAND:
                    grid[i][j] = WATER
                    num_of_lands -= union_connected_land(uf, i, j)
        return num_of_lands
```

> Union Find のところ、
    def find(self, node):
        while self.groups[node] != node:
            self.groups[node] = self.find(self.groups[node])
        return self.groups[node]
ここは、再帰と while が合体していますが、どちらかでいいのでは?
これ、動きます?

> row * m + col
これ、関数化してもいいかもしれません。location_id みたいな名前の。

> row * n + colでした。ちゃんとwidth, heightと名前つけないとだめですね。

3rd

```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        def remove_connected_lands(row, col):
            if not (0 <= row < m and 0 <= col < n):
                return
            if grid[row][col] == WATER:
                return
            grid[row][col] = WATER
            dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]
            for dr, dc in dirs:
                remove_connected_lands(row + dr, col + dc)

        LAND = '1'
        WATER = '0'
        m, n = len(grid), len(grid[0])
        num_of_islands = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == LAND:
                    num_of_islands += 1
                    remove_connected_lands(i, j)
        return num_of_islands
```

> if not (0 <= row < len(grid) and 0 <= col < len(grid[row])):
にしたほうが、どこを走るかの意図は明らかですよね。
ただ、m, n はわりと主役級なので、width, height などの名前をつけてしまってもいいかもしれません。

4th
```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        LAND = '1'
        WATER = '0'
        height, width = len(grid), len(grid[0])

        def remove_connected_lands(row, col):
            if not (0 <= row < height and 0 <= col < width):
                return
            if grid[row][col] == WATER:
                return
            grid[row][col] = WATER
            dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]
            for dr, dc in dirs:
                remove_connected_lands(row + dr, col + dc)

        num_of_islands = 0
        for h in range(height):
            for w in range(width):
                if grid[h][w] == LAND:
                    num_of_islands += 1
                    remove_connected_lands(h, w)
        return num_of_islands
```

5th

BFS。命名や処理が若干違うがだいたい同じ。
```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        LAND = '1'
        WATER = '0'
        height, width = len(grid), len(grid[0])
        
        def visit_land_while_removing(row, col):
            if not (0 <= row < height and 0 <= col < width):
                return
            if grid[row][col] != LAND:
                return
            grid[row][col] = WATER
            visit_land_while_removing(row + 1, col)
            visit_land_while_removing(row - 1, col)
            visit_land_while_removing(row, col + 1)
            visit_land_while_removing(row, col - 1)
        
        num_islands = 0
        for row in range(height):
            for col in range(width):
                if grid[row][col] == LAND:
                    num_islands += 1
                    visit_land_while_removing(row, col)
        return num_islands
```

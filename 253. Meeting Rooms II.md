進行中のMTGの数をトラッキングしてその最大値を返せば良い。

類題で考えると、「部屋に人が出入りしています。最大で何人いるでしょうか？」みたいな問題。
誰が入ったかにはそこまで興味がなくて、人が入室したら1増やして、退出したら1減らせば良い。

1st

```python
class Solution:
    def minMeetingRooms(self, intervals: List[List[int]]) -> int:
        # intervalは左閉右開区間なのでsortした際にENDがSTARTより先に来て欲しい
        MTG_START = 1
        MTG_END = 0

        events = []
        for start, end in intervals:
            events.append((start, MTG_START))
            events.append((end, MTG_END))
        events.sort()

        in_progress = 0
        max_in_progress = 0
        for time, event in events:
            if event == MTG_START:
                in_progress += 1
            else:
                in_progress -= 1
            max_in_progress = max(max_in_progress, in_progress)
        return max_in_progress
```

2nd

変数名、定数名を変えてみた。あとはMTGが終了するタイミングでは最大値を更新しなくて良いので早期にcontinueするようにした。

```python
class Solution:
    def minMeetingRooms(self, intervals: List[List[int]]) -> int:
        EVENT_START = 1
        EVENT_END = 0

        events = []
        for start, end in intervals:
            events.append((start, EVENT_START))
            events.append((end, EVENT_END))
        
        
        events.sort()
        num_of_rooms = 0
        max_rooms = 0
        for time, event_type in events:
            if event_type == EVENT_END:
                num_of_rooms -= 1
                continue
            num_of_rooms += 1
            max_rooms = max(max_rooms, num_of_rooms)
        return max_rooms
```

3rd

```python
class Solution:
    def minMeetingRooms(self, intervals: List[List[int]]) -> int:
        # sort時にENDが先に来るように
        EVENT_START = 1
        EVENT_END = 0

        events = []
        for start_time, end_time in intervals:
            events.append((start_time, EVENT_START))
            events.append((end_time, EVENT_END))
        
        events.sort()
        ongoing_meetings = 0
        needed_rooms = 0
        for event_time, event_type in events:
            if event_type == EVENT_END:
                ongoing_meetings -= 1
                continue
            ongoing_meetings += 1
            needed_rooms = max(needed_rooms, ongoing_meetings)
        return needed_rooms
```

4th

```python
class Solution:
    def minMeetingRooms(self, intervals: List[List[int]]) -> int:
        MEETING_START = 1
        MEETING_END = 0

        events = []
        for start_time, end_time in intervals:
            events.append((start_time, MEETING_START))
            events.append((end_time, MEETING_END))
        
        events.sort()
        num_ongoing_meetings = 0
        num_needed_rooms = 0
        for event_time, event_type in events:
            if event_type == MEETING_END:
                num_ongoing_meetings -= 1
                continue
            num_ongoing_meetings += 1
            num_needed_rooms = max(num_needed_rooms, num_ongoing_meetings)
        return num_needed_rooms
```
5th

終了時間をheapで管理するように。

```python
class Solution:
    def minMeetingRooms(self, intervals: List[List[int]]) -> int:
        max_ongoing_meetings = 0
        current_ongoing_meetings = 0
        end_times = []
        for start, end in sorted(intervals):
            while end_times and end_times[0] <= start:
                current_ongoing_meetings -= 1
                heapq.heappop(end_times)
            current_ongoing_meetings += 1
            max_ongoing_meetings = max(max_ongoing_meetings, current_ongoing_meetings)
            heapq.heappush(end_times, end)
        return max_ongoing_meetings
```

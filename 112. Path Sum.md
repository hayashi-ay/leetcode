再帰で書いていくと良い。終了条件、leafノードかつtargetSumとノードの値が同じになれば良い。
parentノードでは左右のどちらかにTrueがあればTrueになる。nodeの値が負を取れるので、途中でtargetSumを超えたとしても探索は打ち切れない。

1st

```python
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if root is None:
            return False
        if root.left is None and root.right is None:
            return root.val == targetSum
        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)
```

2nd

DFSのiteration、今回の問題では1番深いところまで探索しないと経路の合計が分からないのでDFSの方がBFSより分がある。

```python
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        def is_leaf_node(node):
            return node and node.left is None and node.right is None

        if root is None:
            return False
        # dfsで左側の経路から見ていく
        nodes = [(root, 0)]
        while nodes:
            node, prev_sum = nodes.pop()
            current_sum = prev_sum + node.val
            if is_leaf_node(node):
                if current_sum == targetSum:
                    return True
                else:
                    continue
            if node.right:
                nodes.append((node.right, current_sum))
            if node.left:
                nodes.append((node.left, current_sum))
        return False
```

3rd

1stと同じ。
```python
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if root is None:
            return False
        if root.left is None and root.right is None:
            return root.val == targetSum
        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)
```

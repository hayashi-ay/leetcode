愚直にやるなら前から1文字ずつ見ていってそれぞれ重複がないかを調べる。計算量は $O(n^2)$ で問題の設定上nは最大10^5になるので10^10になりTLEしそうなので別の解法を考える必要がある。
あらかじめユニークな文字を求めたあとで前から見ていけば $O(n)$ でいける。ユニークを求める方法は、各文字の登場回数をカウンティングしたりする感じで良さそう。
ただ上記の方法では2周する必要がある。後ろから見ていって、最後に初めて登場した文字を覚えていれば1回文字列を後ろからなめるだけで解けそう。← と思ったけどそんなことはなくて結構大変そう。


1st

文字の登場回数をあらかじめカウントする。
英アルファベット小文字をインデックス値に変換する処理は関数に切り出しても良いがtoo muchか。

```python
class Solution:
    def firstUniqChar(self, s: str) -> int:
        freq = [0] * 26
        for c in s:
            freq[ord(c) - ord('a')] += 1
        for i, c in enumerate(s):
            if freq[ord(c) - ord('a')] == 1:
                return i
        return -1
```

2nd

1stでは課題の制約で英アルファベット小文字のみだったので配列で管理したがdictを使う版でも解いた。Counterを使っても良い。

```python
class Solution:
    def firstUniqChar(self, s: str) -> int:
        freq = defaultdict(int)
        for c in s:
            freq[c] += 1
        for i, c in enumerate(s):
            if freq[c] == 1:
                return i
        return -1
```

Counterを使った版

```python
class Solution:
    def firstUniqChar(self, s: str) -> int:
        freq = Counter(s)
        for i, c in enumerate(s):
            if freq[c] == 1:
                return i
        return -1
```

3rd

1stと同じ。

```python
class Solution:
    def firstUniqChar(self, s: str) -> int:
        freq = [0] * 26
        for c in s:
            freq[ord(c) - ord('a')] += 1
        for i, c in enumerate(s):
            if freq[ord(c) - ord('a')] == 1:
                return i
        return -1
```

2つの文字列s, tが与えられるので、sのsubstringのうちtに含まれる文字をすべてふくむ最小のsubstringを返す。
愚直にやるとsのsubstringの開始地点をずらしてすべてについて試してみるの。この場合は計算量は、O(mn)になる。`m = len(s), n = len(t)`

Two Pointerを使って区間に含まれる文字をすべてカウントしておいて、tに含まれる文字をすべて含む場合にsubstringを更新していけば良い。
これだと計算量は O(m + n)になる。

1st

考察も合わせて21分ほど。16分時点で書き終えて、1箇所間違いを探すのに残り5分使った。

```python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        expected = defaultdict(int)
        for c in t:
            expected[c] += 1
        actual = defaultdict(int)

        def is_window_substring():
            for c, freq in expected.items():
                if actual[c] < freq:
                    return False
            return True

        minimum_range = (-inf, inf)
        left = 0
        for right in range(len(s)):
            actual[s[right]] += 1
            while is_window_substring():
                min_length = minimum_range[1] - minimum_range[0] + 1
                length = right - left + 1
                if length < min_length:
                    minimum_range = (left, right)
                actual[s[left]] -= 1
                left += 1

        left, right = minimum_range
        if right == inf:
            return ""
        return s[left: right + 1]
```

2nd
命名の変更、打ち切れるところは打ち切るように。

```python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        if len(s) < len(t):
            return ""

        required = defaultdict(int)
        for c in t:
            required[c] += 1
        char_to_freq = defaultdict(int)

        def is_window_substring():
            for c, freq in required.items():
                if char_to_freq[c] < freq:
                    return False
            return True

        minimum_range = (0, len(s))
        left = 0
        for right in range(len(s)):
            char_to_freq[s[right]] += 1
            while is_window_substring():
                min_length = minimum_range[1] - minimum_range[0] + 1
                substring_length = right - left + 1
                if substring_length < min_length:
                    minimum_range = (left, right)
                char_to_freq[s[left]] -= 1
                left += 1
            if len(s) - left < len(t):
                break
        
        left, right = minimum_range
        if right == len(s):
            return ""
        return s[left: right + 1]
```

3rd

window substringかどうかの判定を工夫して毎回全ての文字について確認しなくて良いように。
`minimum_range`を開区間に。

```python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        counts = defaultdict(int)
        for c in t:
            counts[c] += 1
        
        left = 0
        num_used = 0
        minimum_range = (0, len(s) + 1)
        for right in range(len(s)):
            counts[s[right]] -= 1
            if counts[s[right]] >= 0:
                num_used += 1
            while num_used == len(t):
                current_length = minimum_range[1] - minimum_range[0]
                length = right - left
                if length < current_length:
                    minimum_range = (left, right + 1)
                counts[s[left]] += 1
                if counts[s[left]] > 0:
                    num_used -= 1
                left += 1
        start, end = minimum_range
        if end == len(s) + 1:
            return ""
        return s[start:end]
```

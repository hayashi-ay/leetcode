2つの文字列s, tが与えられるので、sのsubstringのうちtに含まれる文字をすべてふくむ最小のsubstringを返す。
愚直にやるとsのsubstringの開始地点をずらしてすべてについて試してみるの。この場合は計算量は、O(mn)になる。`m = len(s), n = len(t)`

Two Pointerを使って区間に含まれる文字をすべてカウントしておいて、tに含まれる文字をすべて含む場合にsubstringを更新していけば良い。
これだと計算量は O(m + n)になる。

1st

考察も合わせて21分ほど。16分時点で書き終えて、1箇所間違いを探すのに残り5分使った。

```python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        expected = defaultdict(int)
        for c in t:
            expected[c] += 1
        actual = defaultdict(int)

        def is_window_substring():
            for c, freq in expected.items():
                if actual[c] < freq:
                    return False
            return True

        minimum_range = (-inf, inf)
        left = 0
        for right in range(len(s)):
            actual[s[right]] += 1
            while is_window_substring():
                min_length = minimum_range[1] - minimum_range[0] + 1
                length = right - left + 1
                if length < min_length:
                    minimum_range = (left, right)
                actual[s[left]] -= 1
                left += 1

        left, right = minimum_range
        if right == inf:
            return ""
        return s[left: right + 1]
```

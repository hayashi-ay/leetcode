BFSで解くのが自然。

1st

BFS。`ans.append(values_of_this_level.copy())`は`copy`しなくても良いが、`copy`しておいた方が変更に強いかなと思いcopyした

```python
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if root is None:
            return []
        nodes = [root]
        ans = []
        while nodes:
            values_of_this_level = []
            next_level = []
            for node in nodes:
                values_of_this_level.append(node.val)
                if node.left:
                    next_level.append(node.left)
                if node.right:
                    next_level.append(node.right)
            ans.append(values_of_this_level.copy())
            nodes = next_level
        return ans
```

2nd

1stの書き直し。
```python
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if root is None:
            return []
        current_level = [root]
        ans = []
        while current_level:
            values = []
            next_level = []
            for node in current_level:
                values.append(node.val)
                if node.left:
                    next_level.append(node.left)
                if node.right:
                    next_level.append(node.right)
            ans.append(values.copy())
            current_level = next_level
        return ans
```

Recursion
```python
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        def order_nodes_by_level(node, level):
            if len(nodes_ordered_by_level) < level:
                nodes_orderd_by_level.append([])
            nodes.prderd_by_level[level - 1].append(node.val)
            if node.left:
                order_nodes_by_level(node.left, level + 1)
            if node.right:
                order_nodes_by_level(node.right, level + 1)
        
        if root is None:
            return []
        nodes_ordered_by_level = []
        order_nodes_by_level(root, 1)
        return nodes_ordered_by_level
```

deque
```python
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if root is None:
            return []
        nodes = deque([(root, 1)])
        ans = []
        while nodes:
            node, level = nodes.popleft()
            if len(ans) < level:
                ans.append([])
            ans[level - 1].append(node.val)
            if node.left:
                nodes.append((node.left, level + 1))
            if node.right:
                nodes.append((node.right, level + 1))
        return ans
```

3rd

だいたい1stと同じ。

```python
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if root is None:
            return []
        nodes = [root]
        ans = []
        while nodes:
            values = []
            next_nodes = []
            for node in nodes:
                values.append(node.val)
                if node.left:
                    next_nodes.append(node.left)
                if node.right:
                    next_nodes.append(node.right)
            ans.append(values)
            nodes = next_nodes
        return ans
```
